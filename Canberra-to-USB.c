// Canberra-to-USB: top-level program that runs the 'input' PIO state machine
// and streams 14-bit samples from the PIO RX FIFO to stdout (USB CDC) as
// compact 2-byte little-endian samples. Designed for the Raspberry Pi Pico
// using the C/C++ SDK.

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "pico/time.h"
#include "tusb.h"
#include "hardware/gpio.h"

// No heartbeat needed for pin state debug

// Local constants - must be visible before including the generated PIO header
#define ADC_COUNT 14
#define BASE_PIN 2
#define READY_PIN 17

#include "input.pio.h"

int main(void) {
	// Enable level shifter: set pin 22 high
	gpio_init(22);
	gpio_set_dir(22, GPIO_OUT);
	gpio_put(22, 1);
	
	// Initialize stdio (USB CDC if enabled in CMake)
	stdio_init_all();
	setvbuf(stdout, NULL, _IONBF, 0);
	sleep_ms(200);

	// Print boot banner
	printf("Canberra-to-USB firmware booted (PIO read mode)\r\n");

	// Select PIO and claim a state machine
	PIO pio = pio0;
	int sm = pio_claim_unused_sm(pio, true);
	if (sm < 0) {
		printf("ERROR: no available PIO state machine\r\n");
		fflush(stdout);
		while (1) tight_loop_contents();
	}

	// Add the assembled PIO program and initialise the SM using the
	// helper generated by pioasm (input_program_init is available in
	// the generated header). This will also configure the GPIOs used by
	// the PIO program.
	uint offset = pio_add_program(pio, &input_program);
	input_program_init(pio, sm, offset, BASE_PIN, READY_PIN);

	// Precompute mask for ADC_COUNT bits
	const uint32_t mask = (1u << ADC_COUNT) - 1u;
	uint64_t sample_count = 0;

	// Main loop: block waiting for samples from the PIO RX FIFO and
	// print them as human-readable decimal values over USB CDC.
	uint32_t zero_run = 0;
	while (1) {
		uint32_t raw = pio_sm_get_blocking(pio, sm);
		// PIO autopush places the pushed bits left-aligned in the 32-bit
		// FIFO word. Extract the ADC_COUNT bits by shifting down before
		// masking. This yields the correct 14-bit sample even when the
		// raw word has data in the high bits (e.g. 0xfbe80000).
		uint16_t sample = (uint16_t)((raw >> (32 - ADC_COUNT)) & mask);

		// Raw debug: print decimal sample and raw 32-bit word in hex
		printf("%u  (raw=0x%08x)\r\n", sample, raw);

		if (raw == 0) {
			zero_run++;
		} else {
			zero_run = 0;
		}

		// Periodic status line every 256 samples
		if ((++sample_count & 0xFF) == 0) {
			uint32_t now_ms = to_ms_since_boot(get_absolute_time());
			int ready = gpio_get(READY_PIN);
			printf("--- STATUS t=%u ms samples=%llu READY=%d zero_run=%u ---\r\n",
				now_ms, (unsigned long long)sample_count, ready, zero_run);
			fflush(stdout);
		}
	}

	return 0;
}
