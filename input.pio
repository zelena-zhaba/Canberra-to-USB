;PIO program that handles input from the Canberra ADC

;Input pins
.define BASE_PIN 2              ; ADC base pin is GP02
.define ADC_COUNT 14            ; ADC data pins are GP02-GP15
.define CDT 16                  ; Composite dead time (Active LOW)
.define READY 17                ; Ready signal from the ADC (Active LOW)
.define INB 18                  ; Discard data if LOW 

;Output pins
.define ACEPT 19                ; Confirm that data was recieved GP19
.define ENDATA 20               ; Open the gates to read the data GP20
.define ENC 21                  ; Enable converter (Active LOW)




.program input
    set pins, 0b101             ; Initial conditions: ACEPT and ENC HIGH (disabled), ENDATA LOW (active).
start:
    jmp !x start [31]       ; Wait for x to be 1. Delay for lighter load.
    set pins, 0b001 [31]    ; Drive ENC LOW, add delay if needed.
    set pins, 0b000 [0]
    wait 1 pin 17 
    set pins, 0b011         
.wrap_target
    wait 0 pin 17           ; READY active-low. Whait for data
    set pins, 0b001         ; Ask ADC to output data
    jmp pin read_data       ; If INB high - capture
    jmp skip_read           ; Else skip
read_data:
    nop [24]                ; Adjust delay for stability
    in pins, 14             ; Shift in 14 bits GP02-GP15 (autopush to FIFO is enabled)
skip_read:
    set pins, 0b010         ; Confirm data is recieved    
    wait 1 pin 17           ; Wait for READY to reset
    set pins, 0b011         ; Return to idle
    ;jmp to start if scratch register x=0
    jmp !x start            ; Go back to start if register x was set to 0 from C
.wrap




% c-sdk {
// this is a raw helper function for use by the user which sets up the GPIO output, and configures the SM to output on a particular pin

void input_program_init(PIO pio, 
                        uint sm, 
                        uint offset 
                        ) 
    {
    //Get default configs.
    pio_sm_config c = input_program_get_default_config(offset);
   
    // Set this pin's GPIO function (connect PIO to the pad)
    for (uint pin = 2; pin < 2 + 14; pin++) {
        pio_gpio_init(pio, pin);}       // ADC00-ADC13 pins
    pio_gpio_init(pio, 16);             // CDT pin
    pio_gpio_init(pio, 17);             // READY pin
    pio_gpio_init(pio, 18);             // INB pin
    pio_gpio_init(pio, 19);             // ACEPT pin
    pio_gpio_init(pio, 20);             // ENDATA pin
    pio_gpio_init(pio, 21);             // ENC pin

    // Set the input base pin 
    sm_config_set_in_pins(&c, 2);

    // Make JMP use the INB pin
    sm_config_set_jmp_pin(&c, 18);

    // Set the output base pin and pin count
    sm_config_set_set_pins(&c, 19, 3);

    // Configure output pin Current
    gpio_set_drive_strength(19, GPIO_DRIVE_STRENGTH_12MA);
    gpio_set_drive_strength(20, GPIO_DRIVE_STRENGTH_12MA);
    gpio_set_drive_strength(21, GPIO_DRIVE_STRENGTH_12MA);

    // Map output pins to output
    pio_sm_set_consecutive_pindirs(pio, sm, 19, 3, true);

    // Enable autopush when ADC_COUNT bits have been shifted in.
    sm_config_set_in_shift(&c, false, true, 14);

    // Joining my FIFOs into one gigachad FIFO
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    // Set clock speed. System clock is 125Mhz = 8ns/cycle
    sm_config_set_clkdiv(&c, 1.0f);

    // Initialize state machine
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}